###############################################################################
# R functions for Qrule analysis and plotting 
###############################################################################
###############################################################################
# Dr. Audrey Lustig
# Bio-Protection Research Centre, Lincoln University, NZ
# May 2016


# Set working directory
# the code require to dowload Qrule at http://www.umces.edu/al/program/gardner/qrule and save it in the exectuable in the folder
# ~/mdig-casestudy/L.Dispar/Data/

working_directory_path <- "path_to_folder_mdig-casestudy/"

output_folder <- "RawLandscapeComponents" # Folder for storing maps generated by Qrule

setwd(paste(working_directory_path,'L.Dispar/Data',sep=''))


###############################################################################
# Create Qrule batchfile

R.batchfile <- list()
index.batchfile <- 1

# Qrule parameter
H.value.range <- c(0.3,0.5,0.7) # Spatial autocorrelation (configuration)
P.value.range <- c(0.35,0.55,0.75) # Percentage of suitable habitat cover in the landscape (composition)
map.type <- "M" # Multifractal map
wrap.map <- "N" # Non wrap
neighborhood.rule <- 2 #8 neighboor
class.number <- 1 #(n-1) number of categorical class
replication <- 10 # number of landscape replication
output.map <- "G" # Output: generated map
analysis.rule <- "R" #Output: Rule analysis
level.number<-7 # Number of fractal level (determines extent)
resolution<-10 # map resolution


# Write parameter in Qrule batchfile 
for (comb in seq(1,length(level.number))){
	e <- level.number[comb]
    	r <- resolution[comb]
    	for (h in H.value.range){
    	    for (p in P.value.range){
    	    	map.name <- paste("Frac.E.",2**e*r,".R.",r,".H.",h,".P.",p*100,sep="")
    		seed<--round(runif(1)*1000000*runif(1))
    		prob <- c(p,1-p)
		output.name.map <- paste("map",index.batchfile,".txt",sep="")
  		R.batchfile[[index.batchfile]]<-list(map.name, map.type, c(e,h), wrap.map, seed, neighborhood.rule, class.number, prob, replication , output.map, output.name.map, analysis.rule, r)
   		index.batchfile<-index.batchfile+1
		}
	}
}
name.R.batchfile <-'Qrule4.2.batchfile.txt'

N=length(R.batchfile)
R.batchfile.dataframe <- data.frame(map.name=rep('', N), map.type=rep('', N), level=rep(-1, N), h=rep(-1, N), wrap.map=rep('', N), seed=rep(-1, N), neighborhood.rule=rep(-1, N), class.number=rep(-1, N), prob=rep(-1, N), prob=rep(-1, N), replication=rep(-1, N), output.map=rep('', N), output.name.map=rep('', N),  analysis.rule=rep('', N), resolution=rep(-1, N), stringsAsFactors=FALSE)          # you don't know levels yet
for (row in 1:N){
  R.batchfile.dataframe[row, ] <- unlist(R.batchfile[[row]])
}

write.table(R.batchfile.dataframe, name.R.batchfile, row.names = FALSE, col.names = FALSE,quote = FALSE, sep =",")



###############################################################################
# R helper functions 

# Returns items in folder b that aren't in a
unique.to.b <- function(a, b){
  comparisons <- matrix(data=NA, length(b), length(a))
  for(r in 1:dim(comparisons)[1]){
    for(c in 1:dim(comparisons)[2]){
      comparisons[r,c] <- a[c]==b[r]
    }
  }
  b[!apply(comparisons, 1 , any)]
}

# Get parameters of each map
get.parameters <- function(input){
  if(input[2]=="M" || input[2] == "m"){
    ascii.name <- as.character(input[1])
    n.rows <- 2**(as.integer(input[3]))
    n.columns <- 2**(as.integer(input[3]))
    n.classes <- as.integer(input[8])
    n.replicates <- as.integer(input[(8+n.classes+2)])
    cell.size <- as.integer(input[(8+n.classes+6)])
    output.name <- as.character(input[(8+n.classes+4)])
   }
  
  if(input[2]=="R" || input[2] == "r"){
    ascii.name <- as.character(input[1])
    n.rows <- as.integer(input[3])
    n.columns <- as.integer(input[4])
    n.classes <- as.integer(input[7])
    n.replicates <- as.integer(input[(7+n.classes+2)])
    cell.size <- as.integer(input[(7+n.classes+6)])
    output.name <- as.character(input[(7+n.classes+4)])
  }
  return(list(ascii.name,cell.size,999,n.rows,n.columns,'IDF_ASCII',n.replicates,output.name))
}


###############################################################################
# Read batchfile and execute QruleV4

l <- list()
# Read in the Qrule batchfile line by line
bfile <- file(name.R.batchfile)
blines <- readLines(bfile)
close(bfile)

# Split up each line based on blank space and commas
blines <- strsplit(blines, "[[:blank:],]+")
# blines is now a list of lists with the outer list holding lines
# and the inner lists holding elements

# Create output folder
if(file.exists(output_folder)==FALSE) {dir.create(output_folder)}

fragstat.batchfile<-list()
index.batchfile<-1
ptm <- proc.time() # start the clock
for(i in 1:length(blines)){ # for each line
  # save the initial file names
  initial.files <- list.files(".")
  # write out script for qrule
  qrs<- file("qrulescript", "w")
  writeLines(c(blines[[i]][-1],' '), con=qrs)
  close(qrs)
  # execute the script
  system(paste(working_directory_path,"L.Dispar/Data/QruleV4.2/Qrule < qrulescript > output.txt",sep=''))
  file.remove("qrulescript")
  param<-get.parameters(blines[[i]])
  new.files <- unique.to.b(initial.files, list.files("."))
  # Need to differentiate maps replicates in different files
  all.replicates.map<-read.table(param[[8]])
  for (r in 1:param[[7]]){
    single.replicates.map<-all.replicates.map[((r-1)*param[[4]]+1):((r-1)*param[[4]]+param[[4]]),]
    file.name<-paste('rawASCIIgrid-rep',r, '.asc', sep="")
    write.table(data.frame(single.replicates.map),file.name,row.names = FALSE, col.names = FALSE)
    # save parameters for fragstat batchfile
    fragstat.batchfile[[index.batchfile]]<-list(paste(working_directory_path,'/',output_folder,'/',blines[[i]][1],".",file.name,sep=""),param[[2]],param[[3]],param[[4]],param[[5]],param[[6]])
	#save map for plotly
    l[[index.batchfile]] <- list(title=paste(param[[1]],'.P.',35,'.rawASCIIgrid-rep',r, '.asc', sep=""), ascii_map=data.frame(single.replicates.map))
    index.batchfile<-index.batchfile+1
  }
  # clean directory: rename folder and put them in the output folder
  new.files <- unique.to.b(initial.files, list.files("."))
  for(f in new.files){
    file.rename(f, paste(output_folder,'/', blines[[i]][1],'.', f, sep=""))
  } # end for each new file
} # end for each line
# Stop the clock
proc.time() - ptm # stop the clock
file.rename(name.R.batchfile, paste(output_folder,name.R.batchfile,sep='/'))


###############################################################################
# Create FRAGSTATS batchfile (to later calculate the landscape metrics for each landscape))
if(file.exists(paste(working_directory_path,'/L.Dispar/Data/LandscapeMetrics',sep=""))==FALSE) {dir.create(paste(working_directory_path,'/L.Dispar/Data/LandscapeMetrics',sep=""))}
fragstat_directory <-paste(working_directory_path,'/L.Dispar/Data/LandscapeMetrics',sep="") # Folder for creating a batchfile for FRAGSTAT (Landscape metrics)
name.fragstat.batchfile <-'fragstat.batchfile.fbt'

N=length(fragstat.batchfile) # fragstat.batchfile was used to save metdata about the maps when generating the neutral maps.
fragstat.batchfile.dataframe <- data.frame(name=rep('', N), cell.size=rep(-1, N),background.value=rep(-1, N),n.rows=rep(-1, N),n.cols=rep(-1, N),format=rep("", N),stringsAsFactors=FALSE)         
for (r in 1:length(fragstat.batchfile)){
  fragstat.batchfile.dataframe[r, ] <- unlist(fragstat.batchfile[[r]])
}

write.table(fragstat.batchfile.dataframe,paste(fragstat_directory,name.fragstat.batchfile,sep="/"),row.names = FALSE, col.names = FALSE,quote = FALSE, sep =",") # save to output folder Fragstats4.1

